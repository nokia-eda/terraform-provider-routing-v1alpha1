// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_system_ping_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func SystemPingListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alarms": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"critical": schema.Int64Attribute{
									Computed: true,
								},
								"major": schema.Int64Attribute{
									Computed: true,
								},
								"minor": schema.Int64Attribute{
									Computed: true,
								},
								"warning": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: AlarmsType{
								ObjectType: types.ObjectType{
									AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"deviations": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"count": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: DeviationsType{
								ObjectType: types.ObjectType{
									AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"address_family": schema.StringAttribute{
									Optional:            true,
									Description:         "AddressFamily is the address family to use for the ping.\nIt can be one of the following values:\n- \"Ipv4\": Use Ipv4 addresses for the ping.\n- \"Ipv6\": Use Ipv6 addresses for the ping.\n- \"DualStack\": Use both Ipv4 and Ipv6 addresses for the ping.",
									MarkdownDescription: "AddressFamily is the address family to use for the ping.\nIt can be one of the following values:\n- \"Ipv4\": Use Ipv4 addresses for the ping.\n- \"Ipv6\": Use Ipv6 addresses for the ping.\n- \"DualStack\": Use both Ipv4 and Ipv6 addresses for the ping.",
								},
								"count": schema.Int64Attribute{
									Optional:            true,
									Description:         "Count is the number of pings to send.",
									MarkdownDescription: "Count is the number of pings to send.",
								},
								"node_selectors": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of node selectors to select nodes whose system interfaces will be pinged.\nThis matches labels on TopoNode resources.\nIf no nodes  and no node selectors and no systemInterfaces as well no systemInterface selectors are specified,\nthen all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
									MarkdownDescription: "List of node selectors to select nodes whose system interfaces will be pinged.\nThis matches labels on TopoNode resources.\nIf no nodes  and no node selectors and no systemInterfaces as well no systemInterface selectors are specified,\nthen all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
								},
								"nodes": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of nodes whose system interfaces will be pinged.\nThis matches names of TopoNode resources.",
									MarkdownDescription: "List of nodes whose system interfaces will be pinged.\nThis matches names of TopoNode resources.",
								},
								"system_interface_selectors": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "SystemInterface Selectors is a list of selectors to execute System pings for.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\", \"eda.nokia.com/region=us-west\"].",
									MarkdownDescription: "SystemInterface Selectors is a list of selectors to execute System pings for.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\", \"eda.nokia.com/region=us-west\"].",
								},
								"system_interfaces": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "SystemInterfaces is a list of named SystemInterface resources to execute System pings for.",
									MarkdownDescription: "SystemInterfaces is a list of named SystemInterface resources to execute System pings for.",
								},
								"timeout_seconds": schema.Int64Attribute{
									Optional:            true,
									Description:         "TimeoutSeconds is the timeout for the ping in seconds.",
									MarkdownDescription: "TimeoutSeconds is the timeout for the ping in seconds.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "SystemPing allows performing ping between systems to their system interfaces.",
							MarkdownDescription: "SystemPing allows performing ping between systems to their system interfaces.",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"details": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"details": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"average_time_nanoseconds": schema.Int64Attribute{
														Computed:            true,
														Description:         "Average time taken for a ping reply.",
														MarkdownDescription: "Average time taken for a ping reply.",
													},
													"max_time_nanoseconds": schema.Int64Attribute{
														Computed:            true,
														Description:         "Maximum time taken for a ping reply.",
														MarkdownDescription: "Maximum time taken for a ping reply.",
													},
													"min_time_nanoseconds": schema.Int64Attribute{
														Computed:            true,
														Description:         "Minimum time taken for a ping reply.",
														MarkdownDescription: "Minimum time taken for a ping reply.",
													},
													"received": schema.Int64Attribute{
														Computed:            true,
														Description:         "Number of pings received.",
														MarkdownDescription: "Number of pings received.",
													},
													"sent": schema.Int64Attribute{
														Computed:            true,
														Description:         "Number of pings sent.",
														MarkdownDescription: "Number of pings sent.",
													},
													"std_dev_nanoseconds": schema.Int64Attribute{
														Computed:            true,
														Description:         "Standard deviation of time taken for all pings.",
														MarkdownDescription: "Standard deviation of time taken for all pings.",
													},
													"total_time_nanoseconds": schema.Int64Attribute{
														Computed:            true,
														Description:         "Total time taken for all pings.",
														MarkdownDescription: "Total time taken for all pings.",
													},
												},
												CustomType: Details1Type{
													ObjectType: types.ObjectType{
														AttrTypes: Details1Value{}.AttributeTypes(ctx),
													},
												},
												Computed:            true,
												Description:         "Details of the ping result, if available.",
												MarkdownDescription: "Details of the ping result, if available.",
											},
											"error": schema.StringAttribute{
												Computed:            true,
												Description:         "Error message, if the ping failed.",
												MarkdownDescription: "Error message, if the ping failed.",
											},
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "Name of the ping result.",
												MarkdownDescription: "Name of the ping result.",
											},
											"success": schema.BoolAttribute{
												Computed:            true,
												Description:         "Indicates if the ping was successful.",
												MarkdownDescription: "Indicates if the ping was successful.",
											},
										},
										CustomType: DetailsType{
											ObjectType: types.ObjectType{
												AttrTypes: DetailsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Details contains the results of the pings performed for each SystemInterface.\nEach entry in the list corresponds to a SystemInterface that was pinged.",
									MarkdownDescription: "Details contains the results of the pings performed for each SystemInterface.\nEach entry in the list corresponds to a SystemInterface that was pinged.",
								},
								"result": schema.StringAttribute{
									Computed:            true,
									Description:         "Result is the overall result of the ping operation.\nIt can be one of the following values:\n- \"Success\": All pings were successful.\n- \"Failed\": No pings were successful.\n- \"PartialSuccess\": Some pings were successful, but not all.",
									MarkdownDescription: "Result is the overall result of the ping operation.\nIt can be one of the following values:\n- \"Success\": All pings were successful.\n- \"Failed\": No pings were successful.\n- \"PartialSuccess\": Some pings were successful, but not all.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The result of the System ping",
							MarkdownDescription: "The result of the System ping",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Deprecated: a label selector string to filter the results based on CR labels",
				MarkdownDescription: "Deprecated: a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type SystemPingListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return nil, diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return nil, diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	Alarms     basetypes.ObjectValue `tfsdk:"alarms"`
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Deviations basetypes.ObjectValue `tfsdk:"deviations"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["alarms"] = basetypes.ObjectType{
		AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deviations"] = basetypes.ObjectType{
		AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Alarms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alarms"] = val

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Deviations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviations"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var alarms basetypes.ObjectValue

	if v.Alarms.IsNull() {
		alarms = types.ObjectNull(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Alarms.IsUnknown() {
		alarms = types.ObjectUnknown(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Alarms.IsNull() && !v.Alarms.IsUnknown() {
		alarms = types.ObjectValueMust(
			AlarmsValue{}.AttributeTypes(ctx),
			v.Alarms.Attributes(),
		)
	}

	var deviations basetypes.ObjectValue

	if v.Deviations.IsNull() {
		deviations = types.ObjectNull(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Deviations.IsUnknown() {
		deviations = types.ObjectUnknown(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Deviations.IsNull() && !v.Deviations.IsUnknown() {
		deviations = types.ObjectValueMust(
			DeviationsValue{}.AttributeTypes(ctx),
			v.Deviations.Attributes(),
		)
	}

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alarms":      alarms,
			"api_version": v.ApiVersion,
			"deviations":  deviations,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alarms.Equal(other.Alarms) {
		return false
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Deviations.Equal(other.Deviations) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.StringValue, was: %T`, addressFamilyAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return nil, diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	systemInterfaceSelectorsAttribute, ok := attributes["system_interface_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface_selectors is missing from object`)

		return nil, diags
	}

	systemInterfaceSelectorsVal, ok := systemInterfaceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface_selectors expected to be basetypes.ListValue, was: %T`, systemInterfaceSelectorsAttribute))
	}

	systemInterfacesAttribute, ok := attributes["system_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interfaces is missing from object`)

		return nil, diags
	}

	systemInterfacesVal, ok := systemInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interfaces expected to be basetypes.ListValue, was: %T`, systemInterfacesAttribute))
	}

	timeoutSecondsAttribute, ok := attributes["timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_seconds is missing from object`)

		return nil, diags
	}

	timeoutSecondsVal, ok := timeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_seconds expected to be basetypes.Int64Value, was: %T`, timeoutSecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AddressFamily:            addressFamilyVal,
		Count:                    countVal,
		NodeSelectors:            nodeSelectorsVal,
		Nodes:                    nodesVal,
		SystemInterfaceSelectors: systemInterfaceSelectorsVal,
		SystemInterfaces:         systemInterfacesVal,
		TimeoutSeconds:           timeoutSecondsVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.StringValue, was: %T`, addressFamilyAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	systemInterfaceSelectorsAttribute, ok := attributes["system_interface_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interface_selectors is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemInterfaceSelectorsVal, ok := systemInterfaceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interface_selectors expected to be basetypes.ListValue, was: %T`, systemInterfaceSelectorsAttribute))
	}

	systemInterfacesAttribute, ok := attributes["system_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_interfaces is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemInterfacesVal, ok := systemInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_interfaces expected to be basetypes.ListValue, was: %T`, systemInterfacesAttribute))
	}

	timeoutSecondsAttribute, ok := attributes["timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_seconds is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	timeoutSecondsVal, ok := timeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_seconds expected to be basetypes.Int64Value, was: %T`, timeoutSecondsAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AddressFamily:            addressFamilyVal,
		Count:                    countVal,
		NodeSelectors:            nodeSelectorsVal,
		Nodes:                    nodesVal,
		SystemInterfaceSelectors: systemInterfaceSelectorsVal,
		SystemInterfaces:         systemInterfacesVal,
		TimeoutSeconds:           timeoutSecondsVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AddressFamily            basetypes.StringValue `tfsdk:"address_family"`
	Count                    basetypes.Int64Value  `tfsdk:"count"`
	NodeSelectors            basetypes.ListValue   `tfsdk:"node_selectors"`
	Nodes                    basetypes.ListValue   `tfsdk:"nodes"`
	SystemInterfaceSelectors basetypes.ListValue   `tfsdk:"system_interface_selectors"`
	SystemInterfaces         basetypes.ListValue   `tfsdk:"system_interfaces"`
	TimeoutSeconds           basetypes.Int64Value  `tfsdk:"timeout_seconds"`
	state                    attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["node_selectors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["system_interface_selectors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["system_interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["timeout_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.NodeSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selectors"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.SystemInterfaceSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_interface_selectors"] = val

		val, err = v.SystemInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_interfaces"] = val

		val, err = v.TimeoutSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout_seconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodeSelectorsVal basetypes.ListValue
	switch {
	case v.NodeSelectors.IsUnknown():
		nodeSelectorsVal = types.ListUnknown(types.StringType)
	case v.NodeSelectors.IsNull():
		nodeSelectorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorsVal, d = types.ListValue(types.StringType, v.NodeSelectors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.StringType{},
			"count":          basetypes.Int64Type{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interface_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.StringType{},
			"count":          basetypes.Int64Type{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interface_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	var systemInterfaceSelectorsVal basetypes.ListValue
	switch {
	case v.SystemInterfaceSelectors.IsUnknown():
		systemInterfaceSelectorsVal = types.ListUnknown(types.StringType)
	case v.SystemInterfaceSelectors.IsNull():
		systemInterfaceSelectorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		systemInterfaceSelectorsVal, d = types.ListValue(types.StringType, v.SystemInterfaceSelectors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.StringType{},
			"count":          basetypes.Int64Type{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interface_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	var systemInterfacesVal basetypes.ListValue
	switch {
	case v.SystemInterfaces.IsUnknown():
		systemInterfacesVal = types.ListUnknown(types.StringType)
	case v.SystemInterfaces.IsNull():
		systemInterfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		systemInterfacesVal, d = types.ListValue(types.StringType, v.SystemInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.StringType{},
			"count":          basetypes.Int64Type{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interface_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.StringType{},
		"count":          basetypes.Int64Type{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_interface_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timeout_seconds": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family":             v.AddressFamily,
			"count":                      v.Count,
			"node_selectors":             nodeSelectorsVal,
			"nodes":                      nodesVal,
			"system_interface_selectors": systemInterfaceSelectorsVal,
			"system_interfaces":          systemInterfacesVal,
			"timeout_seconds":            v.TimeoutSeconds,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.NodeSelectors.Equal(other.NodeSelectors) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.SystemInterfaceSelectors.Equal(other.SystemInterfaceSelectors) {
		return false
	}

	if !v.SystemInterfaces.Equal(other.SystemInterfaces) {
		return false
	}

	if !v.TimeoutSeconds.Equal(other.TimeoutSeconds) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.StringType{},
		"count":          basetypes.Int64Type{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_interface_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timeout_seconds": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return nil, diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return nil, diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Details: detailsVal,
		Result:  resultVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Details: detailsVal,
		Result:  resultVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Details basetypes.ListValue   `tfsdk:"details"`
	Result  basetypes.StringValue `tfsdk:"result"`
	state   attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["details"] = basetypes.ListType{
		ElemType: DetailsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Details.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.Result.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	details := types.ListValueMust(
		DetailsType{
			basetypes.ObjectType{
				AttrTypes: DetailsValue{}.AttributeTypes(ctx),
			},
		},
		v.Details.Elements(),
	)

	if v.Details.IsNull() {
		details = types.ListNull(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Details.IsUnknown() {
		details = types.ListUnknown(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"result": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"details": details,
			"result":  v.Result,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Details.Equal(other.Details) {
		return false
	}

	if !v.Result.Equal(other.Result) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"result": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DetailsType{}

type DetailsType struct {
	basetypes.ObjectType
}

func (t DetailsType) Equal(o attr.Type) bool {
	other, ok := o.(DetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DetailsType) String() string {
	return "DetailsType"
}

func (t DetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	details1Attribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details_1 is missing from object`)

		return nil, diags
	}

	details1Val, ok := details1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details_1 expected to be basetypes.ObjectValue, was: %T`, details1Attribute))
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return nil, diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return nil, diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DetailsValue{
		Details1: details1Val,
		Error:    errorVal,
		Name:     nameVal,
		Success:  successVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueNull() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewDetailsValueUnknown() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DetailsValue Attribute Value",
				"While creating a DetailsValue value, a missing attribute value was detected. "+
					"A DetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DetailsValue Attribute Type",
				"While creating a DetailsValue value, an invalid attribute value was detected. "+
					"A DetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DetailsValue Attribute Value",
				"While creating a DetailsValue value, an extra attribute value was detected. "+
					"A DetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	details1Attribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details_1 is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	details1Val, ok := details1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details_1 expected to be basetypes.ObjectValue, was: %T`, details1Attribute))
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	return DetailsValue{
		Details1: details1Val,
		Error:    errorVal,
		Name:     nameVal,
		Success:  successVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DetailsValue {
	object, diags := NewDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetailsValueMust(DetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DetailsType) ValueType(ctx context.Context) attr.Value {
	return DetailsValue{}
}

var _ basetypes.ObjectValuable = DetailsValue{}

type DetailsValue struct {
	Details1 basetypes.ObjectValue `tfsdk:"details"`
	Error    basetypes.StringValue `tfsdk:"error"`
	Name     basetypes.StringValue `tfsdk:"name"`
	Success  basetypes.BoolValue   `tfsdk:"success"`
	state    attr.ValueState
}

func (v DetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["details"] = basetypes.ObjectType{
		AttrTypes: Details1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["success"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Details1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.Error.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Success.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["success"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DetailsValue) String() string {
	return "DetailsValue"
}

func (v DetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var details1 basetypes.ObjectValue

	if v.Details1.IsNull() {
		details1 = types.ObjectNull(
			Details1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Details1.IsUnknown() {
		details1 = types.ObjectUnknown(
			Details1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Details1.IsNull() && !v.Details1.IsUnknown() {
		details1 = types.ObjectValueMust(
			Details1Value{}.AttributeTypes(ctx),
			v.Details1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"details": basetypes.ObjectType{
			AttrTypes: Details1Value{}.AttributeTypes(ctx),
		},
		"error":   basetypes.StringType{},
		"name":    basetypes.StringType{},
		"success": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"details": details1,
			"error":   v.Error,
			"name":    v.Name,
			"success": v.Success,
		})

	return objVal, diags
}

func (v DetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(DetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Details1.Equal(other.Details1) {
		return false
	}

	if !v.Error.Equal(other.Error) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Success.Equal(other.Success) {
		return false
	}

	return true
}

func (v DetailsValue) Type(ctx context.Context) attr.Type {
	return DetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"details": basetypes.ObjectType{
			AttrTypes: Details1Value{}.AttributeTypes(ctx),
		},
		"error":   basetypes.StringType{},
		"name":    basetypes.StringType{},
		"success": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Details1Type{}

type Details1Type struct {
	basetypes.ObjectType
}

func (t Details1Type) Equal(o attr.Type) bool {
	other, ok := o.(Details1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Details1Type) String() string {
	return "Details1Type"
}

func (t Details1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	averageTimeNanosecondsAttribute, ok := attributes["average_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_time_nanoseconds is missing from object`)

		return nil, diags
	}

	averageTimeNanosecondsVal, ok := averageTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, averageTimeNanosecondsAttribute))
	}

	maxTimeNanosecondsAttribute, ok := attributes["max_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_nanoseconds is missing from object`)

		return nil, diags
	}

	maxTimeNanosecondsVal, ok := maxTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, maxTimeNanosecondsAttribute))
	}

	minTimeNanosecondsAttribute, ok := attributes["min_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_time_nanoseconds is missing from object`)

		return nil, diags
	}

	minTimeNanosecondsVal, ok := minTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, minTimeNanosecondsAttribute))
	}

	receivedAttribute, ok := attributes["received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`received is missing from object`)

		return nil, diags
	}

	receivedVal, ok := receivedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`received expected to be basetypes.Int64Value, was: %T`, receivedAttribute))
	}

	sentAttribute, ok := attributes["sent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sent is missing from object`)

		return nil, diags
	}

	sentVal, ok := sentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sent expected to be basetypes.Int64Value, was: %T`, sentAttribute))
	}

	stdDevNanosecondsAttribute, ok := attributes["std_dev_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`std_dev_nanoseconds is missing from object`)

		return nil, diags
	}

	stdDevNanosecondsVal, ok := stdDevNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`std_dev_nanoseconds expected to be basetypes.Int64Value, was: %T`, stdDevNanosecondsAttribute))
	}

	totalTimeNanosecondsAttribute, ok := attributes["total_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_time_nanoseconds is missing from object`)

		return nil, diags
	}

	totalTimeNanosecondsVal, ok := totalTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, totalTimeNanosecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Details1Value{
		AverageTimeNanoseconds: averageTimeNanosecondsVal,
		MaxTimeNanoseconds:     maxTimeNanosecondsVal,
		MinTimeNanoseconds:     minTimeNanosecondsVal,
		Received:               receivedVal,
		Sent:                   sentVal,
		StdDevNanoseconds:      stdDevNanosecondsVal,
		TotalTimeNanoseconds:   totalTimeNanosecondsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDetails1ValueNull() Details1Value {
	return Details1Value{
		state: attr.ValueStateNull,
	}
}

func NewDetails1ValueUnknown() Details1Value {
	return Details1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewDetails1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Details1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Details1Value Attribute Value",
				"While creating a Details1Value value, a missing attribute value was detected. "+
					"A Details1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Details1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Details1Value Attribute Type",
				"While creating a Details1Value value, an invalid attribute value was detected. "+
					"A Details1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Details1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Details1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Details1Value Attribute Value",
				"While creating a Details1Value value, an extra attribute value was detected. "+
					"A Details1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Details1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetails1ValueUnknown(), diags
	}

	averageTimeNanosecondsAttribute, ok := attributes["average_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	averageTimeNanosecondsVal, ok := averageTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, averageTimeNanosecondsAttribute))
	}

	maxTimeNanosecondsAttribute, ok := attributes["max_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	maxTimeNanosecondsVal, ok := maxTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, maxTimeNanosecondsAttribute))
	}

	minTimeNanosecondsAttribute, ok := attributes["min_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	minTimeNanosecondsVal, ok := minTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, minTimeNanosecondsAttribute))
	}

	receivedAttribute, ok := attributes["received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`received is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	receivedVal, ok := receivedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`received expected to be basetypes.Int64Value, was: %T`, receivedAttribute))
	}

	sentAttribute, ok := attributes["sent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sent is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	sentVal, ok := sentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sent expected to be basetypes.Int64Value, was: %T`, sentAttribute))
	}

	stdDevNanosecondsAttribute, ok := attributes["std_dev_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`std_dev_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	stdDevNanosecondsVal, ok := stdDevNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`std_dev_nanoseconds expected to be basetypes.Int64Value, was: %T`, stdDevNanosecondsAttribute))
	}

	totalTimeNanosecondsAttribute, ok := attributes["total_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	totalTimeNanosecondsVal, ok := totalTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, totalTimeNanosecondsAttribute))
	}

	if diags.HasError() {
		return NewDetails1ValueUnknown(), diags
	}

	return Details1Value{
		AverageTimeNanoseconds: averageTimeNanosecondsVal,
		MaxTimeNanoseconds:     maxTimeNanosecondsVal,
		MinTimeNanoseconds:     minTimeNanosecondsVal,
		Received:               receivedVal,
		Sent:                   sentVal,
		StdDevNanoseconds:      stdDevNanosecondsVal,
		TotalTimeNanoseconds:   totalTimeNanosecondsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDetails1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Details1Value {
	object, diags := NewDetails1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetails1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Details1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetails1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetails1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetails1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetails1ValueMust(Details1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Details1Type) ValueType(ctx context.Context) attr.Value {
	return Details1Value{}
}

var _ basetypes.ObjectValuable = Details1Value{}

type Details1Value struct {
	AverageTimeNanoseconds basetypes.Int64Value `tfsdk:"average_time_nanoseconds"`
	MaxTimeNanoseconds     basetypes.Int64Value `tfsdk:"max_time_nanoseconds"`
	MinTimeNanoseconds     basetypes.Int64Value `tfsdk:"min_time_nanoseconds"`
	Received               basetypes.Int64Value `tfsdk:"received"`
	Sent                   basetypes.Int64Value `tfsdk:"sent"`
	StdDevNanoseconds      basetypes.Int64Value `tfsdk:"std_dev_nanoseconds"`
	TotalTimeNanoseconds   basetypes.Int64Value `tfsdk:"total_time_nanoseconds"`
	state                  attr.ValueState
}

func (v Details1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["average_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["received"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["std_dev_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AverageTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["average_time_nanoseconds"] = val

		val, err = v.MaxTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_time_nanoseconds"] = val

		val, err = v.MinTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_time_nanoseconds"] = val

		val, err = v.Received.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["received"] = val

		val, err = v.Sent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sent"] = val

		val, err = v.StdDevNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["std_dev_nanoseconds"] = val

		val, err = v.TotalTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_time_nanoseconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Details1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Details1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Details1Value) String() string {
	return "Details1Value"
}

func (v Details1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"average_time_nanoseconds": basetypes.Int64Type{},
		"max_time_nanoseconds":     basetypes.Int64Type{},
		"min_time_nanoseconds":     basetypes.Int64Type{},
		"received":                 basetypes.Int64Type{},
		"sent":                     basetypes.Int64Type{},
		"std_dev_nanoseconds":      basetypes.Int64Type{},
		"total_time_nanoseconds":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"average_time_nanoseconds": v.AverageTimeNanoseconds,
			"max_time_nanoseconds":     v.MaxTimeNanoseconds,
			"min_time_nanoseconds":     v.MinTimeNanoseconds,
			"received":                 v.Received,
			"sent":                     v.Sent,
			"std_dev_nanoseconds":      v.StdDevNanoseconds,
			"total_time_nanoseconds":   v.TotalTimeNanoseconds,
		})

	return objVal, diags
}

func (v Details1Value) Equal(o attr.Value) bool {
	other, ok := o.(Details1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AverageTimeNanoseconds.Equal(other.AverageTimeNanoseconds) {
		return false
	}

	if !v.MaxTimeNanoseconds.Equal(other.MaxTimeNanoseconds) {
		return false
	}

	if !v.MinTimeNanoseconds.Equal(other.MinTimeNanoseconds) {
		return false
	}

	if !v.Received.Equal(other.Received) {
		return false
	}

	if !v.Sent.Equal(other.Sent) {
		return false
	}

	if !v.StdDevNanoseconds.Equal(other.StdDevNanoseconds) {
		return false
	}

	if !v.TotalTimeNanoseconds.Equal(other.TotalTimeNanoseconds) {
		return false
	}

	return true
}

func (v Details1Value) Type(ctx context.Context) attr.Type {
	return Details1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Details1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"average_time_nanoseconds": basetypes.Int64Type{},
		"max_time_nanoseconds":     basetypes.Int64Type{},
		"min_time_nanoseconds":     basetypes.Int64Type{},
		"received":                 basetypes.Int64Type{},
		"sent":                     basetypes.Int64Type{},
		"std_dev_nanoseconds":      basetypes.Int64Type{},
		"total_time_nanoseconds":   basetypes.Int64Type{},
	}
}
