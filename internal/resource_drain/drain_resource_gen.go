// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_drain

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DrainResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^routing\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("routing.eda.nokia.com/v1alpha1"),
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Drain$"), ""),
				},
				Default: stringdefault.StaticString("Drain"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Drain",
				MarkdownDescription: "name of the Drain",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"default_router_selector": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Selector to use when selecting DefaultRouters to drain.",
						MarkdownDescription: "Selector to use when selecting DefaultRouters to drain.",
					},
					"default_routers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Reference to DefaultRouters to drain.",
						MarkdownDescription: "Reference to DefaultRouters to drain.",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable this Drain.",
						MarkdownDescription: "Enable this Drain.",
						Default:             booldefault.StaticBool(true),
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Drain allows for the controlled disabling or draining of specific DefaultRouters, either by selecting them through labels or directly referencing them, ensuring traffic is safely rerouted or dropped before the routers are decommissioned.",
				MarkdownDescription: "Drain allows for the controlled disabling or draining of specific DefaultRouters, either by selecting them through labels or directly referencing them, ensuring traffic is safely rerouted or dropped before the routers are decommissioned.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"default_routers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of DefaultRouters this Drain has been applied to",
						MarkdownDescription: "List of DefaultRouters this Drain has been applied to",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "DrainStatus defines the observed state of Drain.",
				MarkdownDescription: "DrainStatus defines the observed state of Drain.",
			},
		},
	}
}

type DrainModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultRouterSelectorAttribute, ok := attributes["default_router_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_router_selector is missing from object`)

		return nil, diags
	}

	defaultRouterSelectorVal, ok := defaultRouterSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_router_selector expected to be basetypes.ListValue, was: %T`, defaultRouterSelectorAttribute))
	}

	defaultRoutersAttribute, ok := attributes["default_routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_routers is missing from object`)

		return nil, diags
	}

	defaultRoutersVal, ok := defaultRoutersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_routers expected to be basetypes.ListValue, was: %T`, defaultRoutersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		DefaultRouterSelector: defaultRouterSelectorVal,
		DefaultRouters:        defaultRoutersVal,
		Enabled:               enabledVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	defaultRouterSelectorAttribute, ok := attributes["default_router_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_router_selector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	defaultRouterSelectorVal, ok := defaultRouterSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_router_selector expected to be basetypes.ListValue, was: %T`, defaultRouterSelectorAttribute))
	}

	defaultRoutersAttribute, ok := attributes["default_routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_routers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	defaultRoutersVal, ok := defaultRoutersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_routers expected to be basetypes.ListValue, was: %T`, defaultRoutersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		DefaultRouterSelector: defaultRouterSelectorVal,
		DefaultRouters:        defaultRoutersVal,
		Enabled:               enabledVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	DefaultRouterSelector basetypes.ListValue `tfsdk:"default_router_selector"`
	DefaultRouters        basetypes.ListValue `tfsdk:"default_routers"`
	Enabled               basetypes.BoolValue `tfsdk:"enabled"`
	state                 attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["default_router_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default_routers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DefaultRouterSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_router_selector"] = val

		val, err = v.DefaultRouters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_routers"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var defaultRouterSelectorVal basetypes.ListValue
	switch {
	case v.DefaultRouterSelector.IsUnknown():
		defaultRouterSelectorVal = types.ListUnknown(types.StringType)
	case v.DefaultRouterSelector.IsNull():
		defaultRouterSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		defaultRouterSelectorVal, d = types.ListValue(types.StringType, v.DefaultRouterSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_router_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_routers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	var defaultRoutersVal basetypes.ListValue
	switch {
	case v.DefaultRouters.IsUnknown():
		defaultRoutersVal = types.ListUnknown(types.StringType)
	case v.DefaultRouters.IsNull():
		defaultRoutersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		defaultRoutersVal, d = types.ListValue(types.StringType, v.DefaultRouters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_router_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_routers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_router_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_routers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_router_selector": defaultRouterSelectorVal,
			"default_routers":         defaultRoutersVal,
			"enabled":                 v.Enabled,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultRouterSelector.Equal(other.DefaultRouterSelector) {
		return false
	}

	if !v.DefaultRouters.Equal(other.DefaultRouters) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_router_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_routers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultRoutersAttribute, ok := attributes["default_routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_routers is missing from object`)

		return nil, diags
	}

	defaultRoutersVal, ok := defaultRoutersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_routers expected to be basetypes.ListValue, was: %T`, defaultRoutersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		DefaultRouters: defaultRoutersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	defaultRoutersAttribute, ok := attributes["default_routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_routers is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	defaultRoutersVal, ok := defaultRoutersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_routers expected to be basetypes.ListValue, was: %T`, defaultRoutersAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		DefaultRouters: defaultRoutersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	DefaultRouters basetypes.ListValue `tfsdk:"default_routers"`
	state          attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["default_routers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DefaultRouters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_routers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var defaultRoutersVal basetypes.ListValue
	switch {
	case v.DefaultRouters.IsUnknown():
		defaultRoutersVal = types.ListUnknown(types.StringType)
	case v.DefaultRouters.IsNull():
		defaultRoutersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		defaultRoutersVal, d = types.ListValue(types.StringType, v.DefaultRouters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_routers": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_routers": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_routers": defaultRoutersVal,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultRouters.Equal(other.DefaultRouters) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_routers": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
